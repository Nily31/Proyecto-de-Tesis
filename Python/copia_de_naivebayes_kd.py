# -*- coding: utf-8 -*-
"""Copia de NaiveBayes-KD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZdWuorTZoPnmN1tu_OmgKLmYtACIIV7_

# **Traer archivo a Colab de forma local**
"""

from google.colab import files
uploaded = files.upload()

"""# **Importar Librerías**"""

# Commented out IPython magic to ensure Python compatibility.
#Librería para manipulación y análisis de datos.
import pandas as pd    
#Librería de funciones matemáticas de alto nivel para operar con vectores y matrices.
import numpy as np    
#Librería para la generación de gráficos a partir de datos contenidos en listas o arrays.    
import matplotlib.pyplot as plt 
#Importamos los mapas de color de Matplotlib.
from matplotlib import colors  
#Librería de nivel superior a Matplotlib que permite generar fácilmente elegantes gráficos.
import seaborn as sb      

#dibuja imágenes estáticas en el cuaderno.
# %matplotlib inline     
#Esto hace que el ancho de la figura sea de 16 de ancho y su altura de 14 pulgadas.       
plt.rcParams['figure.figsize'] = (16, 14) 
#Para crear gráficos declarativamente.
plt.style.use('ggplot') 
 
#Selección deL modelo, nos permite dividir un dataset en dos bloques (entrenamiento y test del modelo).
from sklearn.model_selection import train_test_split 
 #Crea un informe de texto que muestra las principales métricas de clasificación.
from sklearn.metrics import classification_report
#Calcula la matriz de confusión para evaluar la precisión de una clasificación dentro del modelo.
from sklearn.metrics import confusion_matrix 
#Implementa el algoritmo Gaussian Naive Bayes para la clasificación.  
from sklearn.naive_bayes import GaussianNB  
#Selecciona características de acuerdo con las k puntuaciones más altas.
from sklearn.feature_selection import SelectKBest 
#mapa de colores generado a partir de una lista de colores.
from matplotlib.colors import ListedColormap

"""# **Cargar el Dataset (archivo .csv)**"""

#Leer el archivo de datos con encabezado y separados por punto y comas (csv) en DataFrame.
dataframe = pd.read_csv('MasDatosNu.csv', sep=';', index_col=0)  
dataframe.head(10)  #Esta función devuelve las primeras 10 filas del dataset.

"""# **Visualización de Datos**"""

print(dataframe.groupby('classification').size())  #Dividimos los datos en grupos aplicando algunas condiciones en los conjuntos de datos.

sb.catplot('classification',data=dataframe,kind="count", aspect=1) #Graficamos la variable dependiente.

sb.catplot('age',data=dataframe,kind="count", aspect=2.8) #Graficamos la etiqueta edad.

"""# **Histograma de las características**"""

dataframe.drop(['classification'], axis=1).hist()   #Eliminamos la columna dependiente y trazamos los histogramas.
plt.show()       #función para mostrar los histogramas.

"""# **Resumen estadístico de los datos**"""

dataframe.describe() #visualizar detalles estadísticos.

"""# **Feature Selection ó Selección de Características**"""

X=dataframe.drop(['classification'], axis=1) #La X representara nuestras columnas independientes.
y=dataframe['classification']  #La Y representa nuestra columna dependiente.
 
best=SelectKBest(k=8)   #Seleccionamos características que más aportan.
X_new = best.fit_transform(X, y)  #Ajustamos a los datos, luego lo transformamos.
X_new.shape                       #Devuelve las dimensiones de la matriz.
selected = best.get_support(indices=True)  #Obtenemos un índice de las características seleccionadas.
print(X.columns[selected])  #Imprimimos las carcterísticas seleccionadas.

"""# **Grado de Correlación de las características que más aportan**"""

used_features =X.columns[selected] #Creamos una variable que almacenará las columnas con las características seleccionadas.

colormap = plt.cm.viridis  #Obtener mapa de colres RGBA.
plt.figure(figsize=(15,15))  #Asignamos el tamaño de visualización de la gráfica.
plt.title('Pearson Correlation of Features', y=1.05, size=15)  #Colocamos nombre a la gráfica.
sb.heatmap(dataframe[used_features].astype(float).corr(),linewidths=0.1,vmax=1.0, square=True, cmap=colormap, linecolor='white', annot=True)  #Calculamos la correlación por pares de columnas y visualizamos los datos.

"""# **Crear el modelo Gaussian Naive Bayes con SKLearn**

**1. Dividimos nuestros datos de entrada en Entrenamiento y test**
"""

#Decidimos el tamaño de los datos que se deben dividir como conjunto de datos de prueba
X_train, X_test = train_test_split(dataframe, test_size=0.3, random_state=6) 
y_train =X_train["classification"]
y_test = X_test["classification"]

"""**2. Entrenamos el modelo y obtenemos predicciones sobre nuestro conjunto de test**"""

# Instanciamos el clasificador
gnb = GaussianNB()  #La probabilidad de las características es gaussiana.
# Entrenando el clasificador
gnb.fit(
    X_train [used_features].values,
    y_train
)
# Predicción del conjunto de prueba
y_pred = gnb.predict(X_test[used_features])

#Imprimimos el porcentaje de los resultados de entrenamiento y test
print('Precisión en el set de Entrenamiento: {:.2f}'
     .format(gnb.score(X_train[used_features], y_train)))
print('Precisión en el set de Test: {:.2f}'
     .format(gnb.score(X_test[used_features], y_test)))

"""# **Evaluar el Modelo**

**Matriz de Confusión y reporte de métricas**
"""

matriz = confusion_matrix(y_test, y_pred) 

# Graficamos la matriz de confusión
sb.heatmap(matriz, square=True, annot=True, fmt='d', cbar=False ,  annot_kws={'size':20} ,cmap = 'RdBu' )
plt.xlabel('Clase verdadera')
plt.ylabel('Clase predecida')
plt.title('Matriz de Confusión', size=30)
plt.rcParams['figure.figsize']=(5,5)
#plt.show()
print( '\n')
# Imprimimos el reporte de métricas
print('Reporte de Métricas')
print(classification_report(y_test, y_pred))

print("Cantidad de errores de clasificación sobre un total de {0} casos: {1}"
      .format(y_test.shape[0],(y_test != y_pred).sum()))
print("Efectividad del algoritmo: {0: .2f}"
      .format(1 - (y_test != y_pred).sum()/y_test.shape[0]))

"""# **Realizar predicciones en el Modelo creado**

**Resultado esperado**

*    **NotCKD = 0**
*   **CKD = 1**
"""

#                  [sg', 'al',  'hemo',  'pcv',   'rc', 'htn']
print(gnb.predict([[1.02,  1,    15.4,    44,      5.2,   1],
                   [1.025, 0,    15.8,    53,      6.1,   0] ]))